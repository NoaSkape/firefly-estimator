# Database, Authentication & Infrastructure Rules

## CRITICAL: Prevent Production Failures

**Context**: After experiencing MongoDB SSL errors, middleware binding issues, and 500 errors that brought down the entire admin panel, these rules ensure robust infrastructure code from the start.

---

## Rule 1: MongoDB Connection Standards

### ALWAYS use this exact configuration for MongoDB clients:

```javascript
import { MongoClient } from 'mongodb';

const mongoConfig = {
  maxPoolSize: 5,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
  retryWrites: true,
  w: 'majority'
};

// CORRECT: Robust connection with proper configuration
const client = new MongoClient(uri, mongoConfig);
```

### ❌ NEVER do:
```javascript
// Missing proper configuration
const client = new MongoClient(uri, { maxPoolSize: 5 });

// Using deprecated or unsupported options
const client = new MongoClient(uri, { 
  bufferMaxEntries: 0,     // NOT SUPPORTED
  useNewUrlParser: true,   // DEPRECATED
  useUnifiedTopology: true, // DEPRECATED
  ssl: true,               // REDUNDANT (auto-detected)
  sslValidate: true        // NOT SUPPORTED
});

// No error handling
await client.connect();
```

### ✅ ALWAYS do:
```javascript
// Comprehensive error handling
try {
  const client = new MongoClient(uri, mongoConfig);
  await client.connect();
  const db = client.db(dbName);
  return db;
} catch (error) {
  console.error('MongoDB connection error:', error?.message || error);
  // Clean up failed connection attempts
  try { await client?.close(); } catch {}
  throw error;
}
```

---

## Rule 2: Express Middleware Binding

### CRITICAL: Class method binding for middleware

### ❌ NEVER do:
```javascript
// This will cause "Cannot read properties of undefined" errors
router.use((req, res, next) => adminAuth.validateAdminAccess(req, res, next));
router.use(adminAuth.validateAdminAccess); // Missing context binding
```

### ✅ ALWAYS do:
```javascript
// Proper binding for class methods
router.use(adminAuth.validateAdminAccess.bind(adminAuth));

// Or use arrow functions that preserve context
const validateAdmin = (req, res, next) => {
  return adminAuth.validateAdminAccess(req, res, next);
};
router.use(validateAdmin);
```

### Middleware Error Handling Template:
```javascript
// Every middleware MUST have try-catch
async validateAdminAccess(req, res, next) {
  try {
    // Validation logic here
    req.adminUser = userData;
    next();
  } catch (error) {
    console.error('Admin access validation error:', error);
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Access validation failed',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}
```

---

## Rule 3: API Route Error Handling

### MANDATORY: Every API route must have comprehensive error handling

### Template for ALL API routes:
```javascript
router.get('/endpoint', async (req, res) => {
  let db, collection;
  
  try {
    // 1. Database connection with fallback
    try {
      db = await getDb();
      if (!db) throw new Error('Database connection failed');
    } catch (dbError) {
      console.error('Database connection error:', dbError.message);
      return res.status(500).json({ 
        success: false, 
        error: 'Database unavailable',
        data: getDefaultFallbackData() // Always provide fallback
      });
    }
    
    // 2. Collection access with validation
    try {
      collection = db.collection(COLLECTION_NAME);
    } catch (collError) {
      console.error('Collection access error:', collError.message);
      return res.status(500).json({ 
        success: false, 
        error: 'Collection unavailable',
        data: getDefaultFallbackData()
      });
    }
    
    // 3. Query execution with timeout
    try {
      const data = await collection.find(query).limit(100).toArray();
      res.json({ success: true, data: data || [] });
    } catch (queryError) {
      console.error('Query execution error:', queryError.message);
      return res.status(500).json({ 
        success: false, 
        error: 'Query failed',
        data: getDefaultFallbackData()
      });
    }
    
  } catch (error) {
    console.error('Unexpected API error:', error.message || error);
    if (!res.headersSent) {
      res.status(500).json({ 
        success: false, 
        error: 'Internal server error',
        data: getDefaultFallbackData()
      });
    }
  }
});

// ALWAYS provide meaningful fallbacks
function getDefaultFallbackData() {
  return {
    metrics: { totalUsers: 0, activeBuilds: 0, totalOrders: 0, totalRevenue: 0 },
    trends: { dailyRevenue: [], orderStatus: [] },
    recentActivity: { orders: [], builds: [] },
    topModels: []
  };
}
```

---

## Rule 4: Environment Variable Validation

### MANDATORY: Validate all environment variables at startup

### Create environment validation:
```javascript
// lib/envValidation.js
const REQUIRED_ENV_VARS = [
  'MONGODB_URI',
  'MONGODB_DB', 
  'CLERK_SECRET_KEY',
  'CLOUDINARY_CLOUD_NAME',
  'STRIPE_SECRET_KEY'
];

export function validateEnvironment() {
  const missing = REQUIRED_ENV_VARS.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    console.error('❌ Missing required environment variables:', missing);
    throw new Error(`Missing environment variables: ${missing.join(', ')}`);
  }
  
  // Validate MongoDB URI format
  if (!process.env.MONGODB_URI.includes('mongodb')) {
    throw new Error('Invalid MONGODB_URI format');
  }
  
  console.log('✅ Environment variables validated');
}
```

### Use in main API file:
```javascript
// api/index.js - FIRST thing after imports
import { validateEnvironment } from '../lib/envValidation.js';

try {
  validateEnvironment();
} catch (error) {
  console.error('Environment validation failed:', error.message);
  process.exit(1);
}
```

---

## Rule 5: Third-Party Service Initialization

### CRITICAL: Robust client initialization with error handling

### Clerk Client Template:
```javascript
import { createClerkClient } from '@clerk/backend';

let clerkClient = null;

export function getClerkClient() {
  if (clerkClient) return clerkClient;
  
  try {
    if (!process.env.CLERK_SECRET_KEY) {
      throw new Error('CLERK_SECRET_KEY is required');
    }
    
    clerkClient = createClerkClient({
      secretKey: process.env.CLERK_SECRET_KEY
    });
    
    return clerkClient;
  } catch (error) {
    console.error('Failed to initialize Clerk client:', error.message);
    throw new Error('Clerk client initialization failed');
  }
}

// Usage in API routes:
export async function getClerkUsers() {
  try {
    const client = getClerkClient();
    const response = await client.users.getUserList({ limit: 1000 });
    return response.data || [];
  } catch (error) {
    console.error('Clerk API error:', error.message);
    return []; // Always return fallback
  }
}
```

---

## Rule 6: Collection Name Constants

### MANDATORY: Use constants for all collection names

### ❌ NEVER do:
```javascript
// Magic strings scattered throughout code
const builds = db.collection('builds');
const orders = db.collection('Orders'); // Inconsistent casing
const users = db.collection('customers'); // Wrong name
```

### ✅ ALWAYS do:
```javascript
// lib/collections.js
export const COLLECTIONS = {
  BUILDS: 'Builds',
  ORDERS: 'Orders', 
  MODELS: 'Models',
  USER_PROFILES: 'UserProfiles',
  CUSTOMERS: 'Customers'
};

// Usage:
import { COLLECTIONS } from '../lib/collections.js';
const buildsCollection = db.collection(COLLECTIONS.BUILDS);
```

---

## Rule 7: MongoDB Version Compatibility

### CRITICAL: Check supported options for your MongoDB driver version

### How to verify supported options:
```bash
# Check your MongoDB driver version
npm list mongodb

# For MongoDB driver 5.x and 6.x, these options are DEPRECATED or REMOVED:
# - useNewUrlParser: true     (DEPRECATED)
# - useUnifiedTopology: true  (DEPRECATED) 
# - bufferMaxEntries: 0       (REMOVED)
# - ssl: true                 (REDUNDANT - auto-detected)
# - sslValidate: true         (REMOVED)
```

### Safe MongoDB options for modern drivers:
```javascript
const safeMongoConfig = {
  maxPoolSize: 5,                    // ✅ Connection pooling
  serverSelectionTimeoutMS: 5000,   // ✅ Server selection timeout
  socketTimeoutMS: 45000,           // ✅ Socket timeout
  retryWrites: true,                // ✅ Retry failed writes
  w: 'majority'                     // ✅ Write concern
};
```

---

## Rule 8: Database Query Patterns

### MANDATORY: Consistent query patterns with error handling

### Template for counting documents:
```javascript
async function getActiveBuildsCount(db) {
  try {
    const buildsCollection = db.collection(COLLECTIONS.BUILDS);
    const count = await buildsCollection.countDocuments({
      status: { $in: ['DRAFT', 'REVIEW', 'CONFIRMED'] }
    });
    console.log(`[DEBUG] Active builds found: ${count}`);
    return count;
  } catch (error) {
    console.error('Builds count query error:', error.message);
    return 0; // Always return fallback
  }
}
```

### Template for aggregation queries:
```javascript
async function getTotalRevenue(db) {
  try {
    const ordersCollection = db.collection(COLLECTIONS.ORDERS);
    const result = await ordersCollection.aggregate([
      { $match: { status: 'confirmed' } },
      { $group: { _id: null, total: { $sum: '$pricing.total' } } }
    ]).toArray();
    
    const revenue = result[0]?.total || 0;
    console.log(`[DEBUG] Total revenue calculated: $${revenue}`);
    return revenue;
  } catch (error) {
    console.error('Revenue aggregation error:', error.message);
    return 0; // Always return fallback
  }
}
```

---

## Rule 9: Deployment Verification Checklist

### MANDATORY: Before pushing any database/auth changes

### Pre-deployment checks:
```bash
# 1. Verify MongoDB configuration is compatible
node -e "
  import { MongoClient } from 'mongodb';
  const client = new MongoClient('mongodb://localhost', { 
    maxPoolSize: 5,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
    retryWrites: true,
    w: 'majority'
  });
  console.log('✅ MongoDB config syntax valid');
"

# 2. Build succeeds
npm run build

# 3. No lint errors
npm run lint
```

### Post-deployment verification:
1. **Check Vercel logs for MongoDB connection errors**
2. **Verify no "options not supported" errors**
3. **Admin panel loads without 500 errors**
4. **Analytics events process successfully**

---

## Rule 10: Fallback Data Patterns

### ALWAYS provide meaningful fallback data

### Frontend fallback template:
```javascript
// In React components
const [dashboardData, setDashboardData] = useState({
  metrics: { totalUsers: 0, activeBuilds: 0, totalOrders: 0, totalRevenue: 0 },
  trends: { dailyRevenue: [], orderStatus: [] },
  recentActivity: { orders: [], builds: [] },
  topModels: []
});

// API call with fallback
useEffect(() => {
  async function fetchDashboard() {
    try {
      const response = await fetch('/api/admin/dashboard', {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data = await response.json();
        setDashboardData(data.data || dashboardData); // Use fallback
      }
    } catch (error) {
      console.error('Dashboard fetch failed:', error);
      // Keep existing fallback data
    }
  }
  
  fetchDashboard();
}, []);
```

---

## Implementation Priority

When implementing any database, authentication, or infrastructure feature:

1. **Check MongoDB driver version compatibility** 
2. **Start with error handling** (try-catch blocks)
3. **Add environment validation** 
4. **Use supported MongoDB configuration only**
5. **Implement middleware binding correctly**
6. **Add comprehensive logging**
7. **Provide meaningful fallbacks**
8. **Test connection before deployment**

**Remember**: Always verify MongoDB driver option compatibility before deployment. Unsupported options will cause immediate 500 errors across the entire application.